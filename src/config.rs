use std::{convert, env, fmt, path::Path, str};

use crate::Error;

const DEFAULT_FILE: &str = "test";

#[derive(Debug)]
pub enum Action {
    Show,
    Add,
    Help,
    Edit,
}

impl convert::TryFrom<&str> for Action {
    type Error = Error;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "add" => Ok(Action::Add),
            "show" => Ok(Action::Show),
            "edit" => Ok(Action::Edit),
            "help" | "" => Ok(Action::Help),
            cmd => Err(Error::InvalidCommand(cmd.to_string())),
        }
    }
}

impl str::FromStr for Action {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Action::try_from(s)
    }
}

impl fmt::Display for Action {
    // This uses the autogenerated debug trait from `#[derive(Debug)]`
    // to display the enum name.
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug)]
pub struct Config {
    pub action: Action,
    pub input: Option<String>,
    pub file: String,
}

impl Config {
    pub fn from_args(mut args: impl Iterator<Item = String>) -> Result<Config, Error> {
        // first item is binary name
        args.next();

        let action: Action = args.next().unwrap_or_default().as_str().parse()?;

        let input = args.reduce(|mut iter, arg| {
            iter += &format!(" {arg}");
            iter
        });

        let file = env::var("FRIDAY_FILE").unwrap_or_else(|_| DEFAULT_FILE.to_string());
        if !Path::new(&file).is_file() {
            return Err(Error::InvalidArgument(
                "FRIDAY_FILE must point to a valid file".to_string(),
            ));
        };

        Ok(Config {
            action,
            input,
            file,
        })
    }
}

// TODO: add tests https://doc.rust-lang.org/stable/book/ch11-00-testing.html
