use crate::{Error, Result};
use std::{
    collections::HashMap,
    fmt::{self},
    io::{BufRead, BufReader, Read, Write},
    net::{TcpListener, TcpStream, ToSocketAddrs},
    str::{self, FromStr},
};

struct FuncWrapper<'func, T: Write> {
    f: Box<dyn Fn(Request, T) + Send + Sync + 'func>,
}

impl<'func, T: Write> FuncWrapper<'func, T> {
    fn new<F: Fn(Request, T) + Send + Sync + 'func>(f: F) -> FuncWrapper<'func, T> {
        FuncWrapper { f: Box::new(f) }
    }
}

impl<T: Write> Handler<T> for FuncWrapper<'_, T> {
    fn handle(&self, r: Request, rw: T) {
        let f = &self.f;
        f(r, rw)
    }
}

pub struct Server<'handler, T: Write> {
    handlers: Vec<(String, Box<dyn Handler<T> + Send + Sync + 'handler>)>,
}

impl Server<'_, TcpStream> {
    pub fn listen_and_serve<A: ToSocketAddrs>(&self, addr: A) -> Result<()> {
        let listener = TcpListener::bind(addr)?;
        // this was using the threadpool from https://doc.rust-lang.org/stable/book/ch20-02-multithreaded.html
        // before, but the thread::spawn only supports static contexts which makes it pretty hard to use
        // it with self.
        // see https://users.rust-lang.org/t/how-to-use-self-while-spawning-a-thread-from-method/8282.

        for stream in listener.incoming() {
            match stream {
                Ok(s) => self.handle_connection(s),
                Err(e) => log::error!("error in TCP connection: {e}"),
            }
        }
        Ok(())
    }

    fn handle_connection(&self, stream: TcpStream) {
        let r = match parse_request(&stream) {
            Ok(r) => r,
            Err(e) => {
                write(stream, 400, format!("invalid request: {e}"));
                log::error!("invalid request: {e}");
                return;
            }
        };
        for (path, handler) in &self.handlers {
            if r.path.contains(path) {
                handler.handle(r, stream);
                break;
            }
        }
    }
}

impl<'handler, T: Write + 'handler> Server<'handler, T> {
    pub fn new() -> Server<'handler, T> {
        Server {
            handlers: Vec::new(),
        }
    }

    pub fn register_handler<H: Handler<T> + Send + Sync + 'handler>(
        &mut self,
        path: String,
        handler: H,
    ) {
        self.handlers.push((path, Box::new(handler)))
    }

    pub fn register_func<F>(&mut self, path: String, f: F)
    where
        F: Fn(Request, T) + Send + Sync + 'handler,
    {
        self.register_handler(path, FuncWrapper::new(f))
    }
}

pub trait Handler<T: Write> {
    fn handle(&self, r: Request, rw: T);
}

#[derive(PartialEq, Eq, Debug)]
pub enum Method {
    GET,
    POST,
}

impl FromStr for Method {
    type Err = Error;
    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "GET" => Ok(Self::GET),
            "POST" => Ok(Self::POST),
            invalid => Err(Error::InvalidArgument(format!(
                "{invalid} is not an HTTP method"
            ))),
        }
    }
}

impl fmt::Display for Method {
    // This uses the autogenerated debug trait from `#[derive(Debug)]`
    // to display the enum name.
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

pub struct Request {
    pub method: Method,
    pub path: String,
    pub headers: HashMap<String, String>,
    pub body: Option<String>,
}

pub fn write(mut writer: impl Write, status: u16, body: String) {
    let content_length = body.len();
    let reason = match status {
        500 => "Internal Server Error",
        501 => "Not Implemented",
        400 => "Bad Request",
        _ => "OK",
    };

    write!(
        writer,
        "\
HTTP/1.1 {status} {reason}
Content-Length: {content_length}

{body}"
    )
    .unwrap_or_else(|e| log::error!("failed to write response: {e}"))
}

fn parse_request(reader: impl Read) -> Result<Request> {
    let mut reader = BufReader::new(reader);
    let mut lines = reader.by_ref().lines();
    let first_line = match lines.next() {
        Some(Ok(line)) => line,
        // error for empty will be handled in parse_first_line
        None => "".to_string(),
        Some(Err(e)) => {
            return Err(e.into());
        }
    };
    let (method, path, _) = parse_first_line(first_line)?;

    let mut headers: HashMap<String, String> = HashMap::new();
    for line_result in lines {
        let line = line_result?;
        if line.is_empty() {
            break;
        }
        let (key, value) = line.split_once(':').unwrap_or_default();
        headers.insert(key.trim().to_string(), value.trim().to_string());
    }

    let body = read_body(reader, &headers)?;

    Ok(Request {
        method,
        path,
        headers,
        body,
    })
}

fn parse_first_line(s: String) -> Result<(Method, String, String)> {
    let parts: Vec<&str> = s.splitn(3, ' ').collect();
    if parts.len() != 3 {
        return Err(Error::InvalidArgument(
            "invalid number of elements in first HTTP line".to_string(),
        ));
    }
    Ok((
        parts[0].parse()?,
        parts[1].to_string(),
        parts[2].to_string(),
    ))
}

fn read_body(mut reader: impl Read, headers: &HashMap<String, String>) -> Result<Option<String>> {
    let mut body: Option<String> = None;
    let mut body_buffer;
    // https://www.rfc-editor.org/rfc/rfc7230#section-3.2
    if headers.get("Transfer-Encoding").is_some() {
        return Err(Error::InvalidArgument(
            "Tranfer-Encoding is not supported".to_string(),
        ));
    }
    if let Some(size_string) = headers.get("Content-Length") {
        let size: usize = size_string.parse().unwrap_or_default();
        body_buffer = vec![0; size];
        reader.read_exact(&mut body_buffer)?;
        body = Some(String::from_utf8_lossy(&body_buffer).into());
    }
    Ok(body)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_first_line_works() {
        let (method, path, _) = parse_first_line("GET / s".to_string()).unwrap();
        assert_eq!(method, Method::GET);
        assert_eq!(path, "/".to_string())
    }
}
