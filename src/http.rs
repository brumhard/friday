use crate::{threadpool::ThreadPool, Error, Result};
use std::{
    collections::HashMap,
    fmt::{self},
    io::{BufRead, BufReader, Read, Write},
    net::{TcpListener, TcpStream, ToSocketAddrs},
    str::{self, FromStr},
    sync::Arc,
};

struct FuncWrapper<'a, T: Write> {
    f: Box<dyn Fn(Request, T) + Send + Sync + 'a>,
}

impl<'a, T: Write> FuncWrapper<'a, T> {
    fn new<F: Fn(Request, T) + Send + Sync + 'a>(f: F) -> FuncWrapper<'a, T> {
        FuncWrapper { f: Box::new(f) }
    }
}

impl<'a, T: Write> Handler<T> for FuncWrapper<'a, T> {
    fn handle(&self, r: Request, rw: T) {
        let f = &self.f;
        f(r, rw)
    }
}

pub struct Server<'a, T: Write> {
    handlers: Arc<Vec<(String, Box<dyn Handler<T> + Send + Sync + 'a>)>>,
}

impl<'a> Server<'a, TcpStream> {
    pub fn listen_and_serve<A: ToSocketAddrs>(self, addr: A) -> Result<()> {
        let listener = TcpListener::bind(addr)?;
        let thread_pool = ThreadPool::new(4);

        for stream in listener.incoming() {
            match stream {
                Ok(s) => thread_pool.execute(move || handle_connection(&self.handlers, s)),
                Err(e) => log::error!("error in TCP connection: {e}"),
            }
        }
        Ok(())
    }
}

fn handle_connection(
    handlers: &Vec<(String, Box<dyn Handler<TcpStream> + Send + Sync>)>,
    stream: TcpStream,
) {
    let r = match parse_request(&stream) {
        Ok(r) => r,
        Err(e) => {
            write(stream, 400, format!("invalid request: {e}"));
            log::error!("invalid request: {e}");
            return;
        }
    };
    for (path, handler) in handlers {
        if r.path.contains(path) {
            handler.handle(r, stream);
            break;
        }
    }
}

impl<'a, T: Write> Server<'a, T> {
    pub fn new() -> Server<'a, T> {
        Server {
            handlers: Arc::new(Vec::new()),
        }
    }

    pub fn register_handler(
        &'a mut self,
        path: String,
        handler: Box<dyn Handler<T> + Send + Sync + 'a>,
    ) {
        self.handlers.push((path, handler))
    }

    pub fn register_func<F>(&'a mut self, path: String, f: F)
    where
        F: Fn(Request, T) + Send + Sync + 'a,
    {
        self.register_handler(path, Box::new(FuncWrapper::new(f)))
    }
}

trait Handler<T: Write> {
    fn handle(&self, r: Request, rw: T);
}

#[derive(PartialEq, Eq, Debug)]
pub enum Method {
    GET,
    POST,
}

impl FromStr for Method {
    type Err = Error;
    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "GET" => Ok(Self::GET),
            "POST" => Ok(Self::POST),
            invalid => Err(Error::InvalidArgument(format!(
                "{invalid} is not an HTTP method"
            ))),
        }
    }
}

impl fmt::Display for Method {
    // This uses the autogenerated debug trait from `#[derive(Debug)]`
    // to display the enum name.
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

pub struct Request {
    pub method: Method,
    pub path: String,
    pub headers: HashMap<String, String>,
    pub body: Option<String>,
}

pub fn write(mut writer: impl Write, status: u16, body: String) {
    let content_length = body.len();
    let reason = match status {
        500 => "Internal Server Error",
        501 => "Not Implemented",
        400 => "Bad Request",
        _ => "OK",
    };

    write!(
        writer,
        "\
HTTP/1.1 {status} {reason}
Content-Length: {content_length}

{body}"
    )
    .unwrap_or_else(|e| log::error!("failed to write response: {e}"))
}

fn parse_request(reader: impl Read) -> Result<Request> {
    let mut reader = BufReader::new(reader);
    let mut lines = reader.by_ref().lines();
    let first_line = match lines.next() {
        Some(Ok(line)) => line,
        // error for empty will be handled in parse_first_line
        None => "".to_string(),
        Some(Err(e)) => {
            return Err(e.into());
        }
    };
    let (method, path, _) = parse_first_line(first_line)?;

    let mut headers: HashMap<String, String> = HashMap::new();
    for line_result in lines {
        let line = line_result?;
        if line.is_empty() {
            break;
        }
        let (key, value) = line.split_once(':').unwrap_or_default();
        headers.insert(key.trim().to_string(), value.trim().to_string());
    }

    let body = read_body(reader, &headers)?;

    Ok(Request {
        method,
        path,
        headers,
        body,
    })
}

fn parse_first_line(s: String) -> Result<(Method, String, String)> {
    let parts: Vec<&str> = s.splitn(3, ' ').collect();
    if parts.len() != 3 {
        return Err(Error::InvalidArgument(
            "invalid number of elements in first HTTP line".to_string(),
        ));
    }
    Ok((
        parts[0].parse()?,
        parts[1].to_string(),
        parts[2].to_string(),
    ))
}

fn read_body(mut reader: impl Read, headers: &HashMap<String, String>) -> Result<Option<String>> {
    let mut body: Option<String> = None;
    let mut body_buffer;
    // https://www.rfc-editor.org/rfc/rfc7230#section-3.2
    if headers.get("Transfer-Encoding").is_some() {
        return Err(Error::InvalidArgument(
            "Tranfer-Encoding is not supported".to_string(),
        ));
    }
    if let Some(size_string) = headers.get("Content-Length") {
        let size: usize = size_string.parse().unwrap_or_default();
        body_buffer = vec![0; size];
        reader.read_exact(&mut body_buffer)?;
        body = Some(String::from_utf8_lossy(&body_buffer).into());
    }
    Ok(body)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_first_line_works() {
        let (method, path, _) = parse_first_line("GET / s".to_string()).unwrap();
        assert_eq!(method, Method::GET);
        assert_eq!(path, "/".to_string())
    }
}
