use friday::{Error, Result};
use std::{
    collections::HashMap,
    env,
    fmt::{self},
    io::{BufRead, BufReader, Read, Write},
    net::{TcpListener, TcpStream},
    process,
    str::{self, FromStr},
};

fn main() {
    // see https://github.com/rust-lang/log
    env_logger::init_from_env(env_logger::Env::default().default_filter_or("INFO"));

    let port: u16 = env::var("PORT").unwrap_or_default().parse().unwrap_or(7878);

    run(port).unwrap_or_else(|e| {
        eprint!("error during run: {e}");
        process::exit(1)
    })
}

fn run(port: u16) -> Result<()> {
    let listener = TcpListener::bind(format!("127.0.0.1:{port}"))?;

    for stream in listener.incoming() {
        match stream {
            Ok(s) => handle_connection(s),
            Err(e) => log::error!("error in TCP connection: {e}"),
        }
    }
    Ok(())
}

fn handle_connection(mut stream: TcpStream) {
    let r = match parse_request(&mut stream) {
        Ok(r) => r,
        Err(e) => {
            write_http(stream, 400, format!("invalid request: {e}"));
            log::error!("invalid request: {e}");
            return;
        }
    };
    println!("method: {}, path: {}", r.method, r.path);
    println!("headers: {:#?}", r.headers);
    println!("body: {:#?}", r.body);
    println!("handling connection")
}

#[derive(PartialEq, Eq, Debug)]
enum Method {
    GET,
    POST,
}

impl FromStr for Method {
    type Err = Error;
    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "GET" => Ok(Self::GET),
            "POST" => Ok(Self::POST),
            invalid => Err(Error::InvalidArgument(format!(
                "{invalid} is not an HTTP method"
            ))),
        }
    }
}

impl fmt::Display for Method {
    // This uses the autogenerated debug trait from `#[derive(Debug)]`
    // to display the enum name.
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

struct Request {
    method: Method,
    path: String,
    headers: HashMap<String, String>,
    body: Option<String>,
}

fn write_http(mut writer: impl Write, status: u16, body: String) {
    let content_length = body.len();
    let reason = match status {
        500 => "Internal Server Error",
        400 => "Bad Request",
        _ => "OK",
    };

    write!(
        writer,
        "\
HTTP/1.1 {status} {reason}
Content-Length: {content_length}

{body}"
    )
    .unwrap_or_else(|e| log::error!("failed to write response: {e}"))
}

fn parse_request(reader: impl Read) -> Result<Request> {
    let mut reader = BufReader::new(reader);
    let mut lines = reader.by_ref().lines();
    let first_line = match lines.next() {
        Some(Ok(line)) => line,
        // error for empty will be handled in parse_first_line
        None => "".to_string(),
        Some(Err(e)) => {
            return Err(e.into());
        }
    };
    let (method, path, _) = parse_first_line(first_line)?;

    let mut headers: HashMap<String, String> = HashMap::new();
    for line_result in lines {
        let line = line_result?;
        if line.is_empty() {
            break;
        }
        let (key, value) = line.split_once(':').unwrap_or_default();
        headers.insert(key.trim().to_string(), value.trim().to_string());
    }

    let body = read_body(reader, &headers)?;

    Ok(Request {
        method,
        path,
        headers,
        body,
    })
}

fn parse_first_line(s: String) -> Result<(Method, String, String)> {
    let parts: Vec<&str> = s.splitn(3, ' ').collect();
    if parts.len() != 3 {
        return Err(Error::InvalidArgument(
            "invalid number of elements in first HTTP line".to_string(),
        ));
    }
    Ok((
        parts[0].parse()?,
        parts[1].to_string(),
        parts[2].to_string(),
    ))
}

fn read_body(mut reader: impl Read, headers: &HashMap<String, String>) -> Result<Option<String>> {
    let mut body: Option<String> = None;
    let mut body_buffer;
    // https://www.rfc-editor.org/rfc/rfc7230#section-3.2
    if headers.get("Transfer-Encoding").is_some() {
        return Err(Error::InvalidArgument(
            "Tranfer-Encoding is not supported".to_string(),
        ));
    }
    if let Some(size_string) = headers.get("Content-Length") {
        let size: usize = size_string.parse().unwrap_or_default();
        body_buffer = vec![0; size];
        reader.read_exact(&mut body_buffer)?;
        body = Some(String::from_utf8_lossy(&body_buffer).into());
    }
    Ok(body)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_first_line_works() {
        let (method, path, _) = parse_first_line("GET / s".to_string()).unwrap();
        assert_eq!(method, Method::GET);
        assert_eq!(path, "/".to_string())
    }
}
